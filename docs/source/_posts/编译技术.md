# 玩具编译器 cookbook

## 背景

这学期开了编译技术的课，课设就是做一个小型编译器。做的过程中有很多收获，也踩了不少坑。故而简单记录一下一个可以生成目标代码的玩具编译器所需要的过程。

## HELLO-C 介绍

### 前言

因为时间紧任务重，课设时间不到一个月，还有各种其他作业考试和项目，故而只能坚持一个原则——简单粗暴

走一遍流程，稳快好的搞定一个玩具编译器。

从定义文法开始，坚持不挖坑的原则，尽量避开能想到的坑。

制作过程糙快猛，不追求细节的尽善尽美，但还是要保证底线。

保证代码规范，保证模块间依赖清晰，尽量不犯蠢。

一些细节会被忽略，比如不考虑内存泄露，只污染不治理。

**特别提醒！该说明只是简单记录过程，不是 Step By Step 的教程。**

**使用 Flex + Bison + LLVM + C 完成编译器**

### 前置要求

1. Linux/OSX 下构建，不考虑 Windows，不会详细描述环境的搭建过程
2. 了解简单的命令
3. 对 CMake、MakeFile 有一定了解
4. 对 C/C++ 有一定了解
5. Flex/Bison 的使用请善用搜索引擎

### 语法

![image-20191128234753437](%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF.assets/image-20191128234753437.png)

大体采用 C 风格。

为了简单，一个源文件由三部分组成。

1. struct 定义。struct 内只能有基本类型，int float 和 char
2. 全局变量定义
3. 函数定义

```c
struct A {
  int a;
  float b;
}

int c;

void fun(int d, int f) {
  int h;
  float g;
  A stru;
  int [d + 1][f * 2] array;
  h = 0;
  g = 2.0;
  stru.a = -1;
  if (a == 0) {
    h = 1;
  } else {
    while (h > 0) {
    	g++;
      break;
      continue;
    }
  }
  return 0;
}
```

不考虑逻辑正确性，给出一个程序示例。以上便是支持的全部语法。

**注意：为了简单~~懒~~，声明归声明，赋值归赋值，变量声明的同时不能初始化。默认初始化为 0**

（因为支持数组，我在考虑要不要加入对 for 的支持）

语法检查时数组只检测维度，不检查是否越界。

（感觉支持动态数组又是一个大坑… 大不了 malloc 了事）

为了避免逃逸分析，没有显式引入指针。也就是所有的临时变量都是栈上变量（array 可能例外，暂时还没实现到 array）函数调用都是传拷贝。全局变量存储在堆空间。

支持递归

函数体由 stm 组成。

这也是与 c 有一定差异的地方。stm 无值，exp 有值。

if/while 的 test 块为 exp。

stm：

1. 赋值 stm 即 a = exp；
2. 变量声明 int a;
3. if/while
4. break/continue/return

exp：

1. 函数调用 fun(1, 9);
2. 单目运算
3. 双目运算
4. 右值（左值 + 常量）

左值有三种

1. 简单变量引用
2. 结构体变量引用
3. 数组引用

## 编译器结构（C 项目结构）

作为一名 Java 程序员…对 C 项目的组织经验确实不多。

之前对于依赖管理等等可以说是一无所知乱完全乱搞。

所幸之前看过一点虎书，虎书所用的管理方式虽然存在一点问题，但是相对还是比较清晰的。这次大体上采用虎书的项目规范。

1. 头文件内不 include（理论上头文件应该自洽，但是不想写 ifndef 这一套，就简单的不在头文件内 include 了）
2. struct 命名 M_xxxx_ M 为模块的简称，比如 AST 模块为 A。xxxx 采用小驼峰。最后要加一个下划线
3. typedef M_xxxx_ * M_xxxx 在来个 typedef，写起来方便一点
4. 结构体构造函数为  xxxx 的大驼峰。
5. 其余按照 Java 规范来。大括号不换行。

构建系统使用 CMake。

## 词法分析 & 语法分析

对于我们的编译器来说，输入的是一个源文件，也可以简单的理解为是字符的组合。但是如果整个编译过程中操作的都是字符串的话，那未免太过复杂。所以要对源文件经过某些预处理。就像做饭一样，要先把食材洗净切好，分门别类的摆好再开始。而词法分析和语法分析就是类似于这样的步骤。

当然和切菜不同，词法分析和语法分析更多的是一个规约的过程，就是把某种零散的元素规约整理成联系更加紧密的结构。

### 词法分析

```c
int fun(int b) {
	int a = 0;
  a += 5;
  return a;
}
```

看这段简单的程序，可以说它是一个函数。

这个函数又由返回值类型、函数名、参数表和函数体组成。

继续细化的话可以说每一个部分都由一个或多个词组成。也就是所谓的 TOKEN。我们真正关心的不是 int 由 i、n 和 t 组成，而是 int 这个词所代表的含义。

这就是词法分析的工作，从源文件中提取出一个一个的词，以简化后续的工作。

比如这段代码经过词法分析之后的输出可能是 

```
ID ID LPAREN ID ID RPAREN LBRACE
ID ID ASSIGN INT SEMICOLON
				....
```

这样我们下一步工作的处理单位就从字符变成了 TOKEN。

对于 TKOEN 的提取可以采用正则表达式来完成，关于正则表达式的内容可以查阅相关资料。

这里采用 FLEX 来做词法分析。FLEX 会根据我们所制定的规则生成一个自动机，它会在每次调用 yylex 函数时候返回 yyin 中下一个匹配到某条规则所对应的 TOKEN ID… 

### 语法分析

每种语言都有其对应的文法，也就是其 TOKEN 组成的规则。

比如如果出现这样的 TOKEN 序列，我们可以说这可能是一个声明

``` 
ID ID (int a)
```

但如果出现这样的序列，我们就无法将其对应到某条规则

```
ID ID ID
```

而语法分析就是将 TOKEN 规约成符合文法的结构。一般为抽象语法树 (Abstract Syntax Tree)

![image-20191206143822656](%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF.assets/image-20191206143822656.png)

需要注意的是我们词法分析产生的 AST 是不考虑语义内容的，只考虑语法内容。也就是下边的表述在语法分析中是符合规则并且可以生成 AST 的。

```
int a;
a = 1.1;// 虽然把 float 赋值给 int 型变量，但是是符合文法的
```

但是下边的表述是不符合语法的

```
int a,
a = 1, // 一个语句的结束应该是 ';' 而不是 ','
```

和词法分析类似，我们使用 Bison 来生成语法分析器。

### 有限状态自动机

词法分析和语法分析是状态机非常典型的应用。

我所理解的状态机简单来说主要由两部分组成，一部分是状态，另一部分是状态间转化的规则。

当状态机处于某个状态，收到某种输入时，它就跳转到另一个状态，同时执行某些特定的操作。

## 语义分析

语义分析就是一个静态检查的过程。就如刚才提到的，有很多满足文法的表述其实是不合法的。语义分析就是找到一部分这样的错误。比如把一个浮点数赋值给一个 int 类型的变量，这样的异常是可以在语义检查中发现的。

## 符号表

程序的合法性要建立在一定的上下文中。而符号表就是及其重要的上下文之一。

比如

``` c
void fun1() {
	int a;
  a = 1; // 合法
 	b = 2; // 不合法
}

void fun2() {
  int a;
  int b;
  a = 1; // 合法
  b = 2; // 合法
}
```

b = 2 的语句在 fun1 中就是不合法的。因为其上下文中没有定义 b 的符号。

我们把上下文的符号记录在一个叫符号表的结构里。

分析实现符号表的需求：

1. 因为有很多查询的过程，所以符号表的查询性能要好
2. 符号上下文在变化，所以符号表应该有添加和删除的能力
3. 符号有作用域，符号表要控制符号的作用域

综合以上，对于第一条，哈希表无疑是最佳选择之一。

对于第二三条，栈显然是非常好的选择。

故而符号表的存储结构靠哈希表来实现，以达到常数复杂度的查询性能。

同时加入辅助指针，以保持栈的结构。

![image-20191206150718592](%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF.assets/image-20191206150718592.png)

大概是这样的结构。可以通过 hash 快速查找到对应的 node，同时也保证了栈的顺序。 top 指针即栈顶。具体的结构定义可查阅项目源代码的 include/table.h

## LLVM C Interface

代码生成采用 LLVM 来做，而写这篇说明最直接的原因就是我在 LLVM 的使用上遇到了一些问题。

LLVM 提供了很多接口，使用更为广泛的应该是 C++ 接口。但是我因为不想~~不会~~写 C++，故而决定通过 C 接口来使用 LLVM。这也是坑的开始…

C 接口其实是 C++ 接口的封装，故而有一些没有封装的 API 用起来就比较难受了…

其次 C 接口的文档并不是很完善，也没有什么注释，很多用法还是要回到被封装的 C++ 接口找答案。

同时 C 接口的 Demo 也很少，似乎用的人不是很多…

综上，建议直接使用 C++ 接口…

但是… 就玩具的需求来说，C 接口已经足够了。写这篇文章就是为了总结一下 C 接口简单的使用 hhh。

### SSA

[SSA WiKi](https://en.wikipedia.org/wiki/Static_single_assignment_form)

### global variables



![image-20191202110013586](%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF.assets/image-20191202110013586.png)

![image-20191202110131130](%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF.assets/image-20191202110131130.png)

[GEP](https://llvm.org/docs/GetElementPtr.html)

