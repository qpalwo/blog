---
title: 初学者对 git 的重新认识
date: 2019-10-17 20:59:43
tags: git

---



## WIP

还隐约记得当时第一次接触 git 时的场景。用一脸懵逼形容没有一点不妥。光是区分 git 和 github 的联系和区别就用了很久。看到一堆的命令也是感觉陌生而又头疼。对 Android Studio 提供的图形工具也是爱不释手。

直到现在，也敲了很多命令，也使用 git 做了一些工作，又翻了一下 git 官方文档，才意识到了自己的成长。

该文章写给初学者，但是为了不过多的停留在细节的东西，假设读者对命令行的工作方式有一定的认识，对 git 的功能有一定的了解，且假设读者对 Linux/Unix 有一定的认识。

<!-- more -->

# 初见

我不知道大家在第一次使用 git 的时候是什么心理。但我当时一定是满头大汗自顾不暇的。沉迷于各种教程，却还是难得精髓。

直到逐渐有了一点实践经验，才得空可以思考 git 是怎样做到这非常神奇的功能的。

又翻开了 git 官方文档 [git 文档]([https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-%E5%BA%95%E5%B1%82%E5%91%BD%E4%BB%A4%E5%92%8C%E9%AB%98%E5%B1%82%E5%91%BD%E4%BB%A4](https://git-scm.com/book/zh/v2/Git-内部原理-底层命令和高层命令)) ，却有了完全不同的体验。发现了很多好玩的东西，有趣的干货。这部分内容就不在此赘述，之后可以再写一篇。本文的重心放在 git 内部原理上。

# 正戏

## 简述

受到 git diff 的影响，其实我一直认为 git 保存的就是 diff 的内容。还一直好奇它是怎样做到如此高效的提取和恢复两个文件的 diff 。简单了解时候才发现这种说法可对可不对。

git 其实可以理解为是一个 K-V 数据库。

没错 git 存贮的就是许许多多的 K-V 对。

K 就是根据文件内容计算出来的哈希值。V 就是 加入描述性文本经 zlib 压缩后的文件内容。根据哈希的特性，只要文件内容发生了改变，那它的哈希值就会发生变化，从而 git 也就可以监测到文件的变化。

K-V 是一种很神奇的结构，它表示了一种关系。它可以给两个原本可能互不相干的东西建立一种联系。而各种各样组织数据的方式都离不开这种联系。某种程度上可以把 key 看作指针，指向某个特定的内容。

简单的讲，以上就是我所认识的 git 的全部。

## 具体解释

每一个 git 项目都有一个神奇的 .git 目录。这个目录里存储了 git 工作所需要的资料。刚刚我讲到 git 就是一个 K-V 数据库，而数据库的内容大部分都保存在 .git 目录下的 objects 文件夹中。

{% asset_img image-20191022100218849.png img %}

在这个文件夹中，会看到很多类似 1a、5b 一类的文件夹，文件夹里又是长长的看上去无意义的数字和字母的组合。其实这里涉及到一个很关键的概念，每个文件和它所在的文件夹的名字就是根据文件内容经过哈希函数所得的值，也就是 K-V 数据库中的 key。而文件的内容理所应当的就是文件的内容了。当然是在添加了一定的描述性文本经 zlib 压缩之后的内容，所以直接打开之后也是不可读的。

每一个文件都是一个对象。每一个对象都代表着一段内容的哈希值到内容的联系。

而 git 就是工作在这样许许多多的对象所构成的联系之上的。

### 底层命令

除了之前熟悉的 pull push 这一类的上层命令接口，git 还有一套底层命令，能够对 git 进行更加深入灵活的控制。这篇文章中会较多的涉及到一些底层命令的使用，也会通过用底层命令实现上层接口功能的方式来使读者更加深刻的理解 git 上层命令。

文中会用到的底层命令如下：

1. git hash-object 用于将一段内容生成 blob 对象
2. git cat-file 用于显示出对象的内容

### blob

blob 对象是基本对象之一。每一个 blob 对象都代表着项目中的一个文件夹在某一个时刻的完整快照。

调用 **git hash-object** 命令可以把一个 stdin 输入的流或者是一个文件经过 git 的规则转化成 blob 对象存入库中。

{% asset_img image-20191022162231775.png img %}

--stdin 表示从 stdin 接受输入内容。-w 参数表示把生成的对象保存到数据库中。

输出的一段字符就是 git 通过特定的哈希算法根据文本内容所计算出的 hash code。也可理解为该 blob 对象的 key。

可以通过 **git cat-file** 命令来验证我们的结果

{% asset_img image-20191022162711988.png img %}

-p 参数会输出对象的内容， -t 参数会输出对象的类型。由此可见我们刚刚通过 git 底层命令生成了一个 blob 类型的对象，它的 key 的前五位为 45b98，内容为 hi

### tree

简单来说可以把 blob 看作文件内容，但是可以想象，我们日常使用的文件系统都是树形结构，一个文件夹内可能还有多个文件夹或者多个文件。

{% asset_img image-20191022164648393.png img %}

如果说 blob 对应文件，那么 tree 对象可以理解为一个文件夹的角色，把文件组成文件系统。值得一提的是，一个文件的文件名是保存在 tree 对象中的，而不是 blob 对象中。

{% asset_img data-model-1.png img %}

通过 tree 对象和 blob 对象，git 便可以建立一个文件目录所需要的关联了。

tree 对象的创建一般不像 blob 那样随意，往往要根据当前暂存区的状态生成一个 tree 对象。

所以为了创建一个 tree 对象，我们要先创建一个暂存区。

{% asset_img image-20191022170637922.png img %}

git update-index 命令可以创建一个暂存区，--add 参数表示将对象添加到暂存区，--cacheinfo 指示该对象来自对象库，100644 是文件模式，表示该文件为普通文件。最后一个参数指示该对象的名字。

接下来就可以通过 git write-tree 命令产生一个 tree 对象并且写入对象库

{% asset_img image-20191022171731843.png img %}

可见我们创建了一个 tree 对象。并且有一个叫 test.file 的文件，且其 hash code 和我们之前的 hash code 一样。

{% asset_img image-20191022171907654.png img %}

### commit





